#+TITLE:   Rafa's Emacs settings file
#+AUTHOR:  Rafa de Castro
#+EMAIL:   rafael@micubiculo.com
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

[[file:emacs-logo.png]]

To use this change your init file for something like

#+BEGIN_SRC
(require 'org)
(org-babel-load-file
 (expand-file-name "settings.org"
                   user-emacs-directory))
#+END_SRC

Then you will only have your org file to handle all your emacs configuration. It may sound overkill in the beginning. I'm testing this too ;)

At this moment all features are in external el files. I'm migrating from those to this dile only so there are some *load-file*s out there yet.

* Use package

Bootstrapping use-package. This looks for use package in the system ans installs it if it is not there. This is the only package we need to install this way.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(eval-when-compile
  (require 'use-package))
(require 'diminish)                ;; if you use :diminish
(require 'bind-key)                ;; if you use any :bind variant
#+END_SRC

* Homebrew

I'll add homebrewe'd emacs packages to load path

#+BEGIN_SRC emacs-lisp
(let ((default-directory "/usr/local/share/emacs/site-lisp/"))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC


* Shell

Copy the environment variables from shell's environment

#+BEGIN_SRC emacs-lisp

(use-package exec-path-from-shell
  :ensure t
  :no-require t
  :config (when (memq window-system '(mac ns))
            (exec-path-from-shell-initialize)))
#+END_SRC

Also set zsh shell with login as default

#+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
(setq multi-term-program-switches "--login")
#+END_SRC

Using multi-term as terminal emulator. I'm not still 100% sure on this

#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :ensure t)
#+END_SRC

* Editing settings

I'll add a function to edit settings.org file. I don't need a shortcut since this is not such a common task now.

#+BEGIN_SRC emacs-lisp
(defun settings ()
  "Edits settings.org file"
  (interactive)
  (find-file "~/.emacs.d/settings.org"))
#+END_SRC

* Visuals

** General UI

Remove scrollbars. One extra character per line and goodbye to that unthemed thing :P

#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
#+END_SRC

Disable menu and icon bar

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC

Show full path of file in status bar

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '(:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) "%b")))
#+END_SRC

Show line numbers

#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
#+END_SRC

Paren highlight
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Asking y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

We will use rainbow delimiters when possible

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

Highlight current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC


** Whitespace

Use spaces instead of tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Nothing bigger than 80 lines. This is nice also for code. ;). Anyway we can avoid the org node since this may make sense for longer texts.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :diminish whitespace-mode
  :config (progn (setq whitespace-line-column 120)
                 (setq whitespace-style '(face empty tabs lines-tail trailing))
                 (setq whitespace-global-modes '(not org-mode web-mode "Web" emacs-lisp-mode))
                 (global-whitespace-mode t)))
#+END_SRC

Enable word wrap globally.

#+BEGIN_SRC emacs-lisp
(global-visual-line-mode t)
(diminish 'visual-line-mode)
#+END_SRC

** Theme and fonts

I'm trying to design a more calm theme. It gets me in the mood for a good cup of coffee and a nice calm talk.

I don't like the default gutter since the separation between 2 frames is too difficult to see.

#+BEGIN_SRC emacs-lisp
(use-package labburn-theme
  :ensure t
  :config (progn
            (load-theme 'labburn t)
            (set-face-attribute 'fringe nil :background "#444444" :foreground "#E1E1D4")
            (set-face-attribute 'linum nil :background "#444444" :foreground "#E1E1D4")))
#+END_SRC

Font. I like a ton of different fonts and I use them a lot. My choices are:

+ Hermit / light: Playful. Coding must be fun.
+ M+ 1mn / light: When you are feeling professional
+ Input Mono Compressed: Somewhat old school but really readable.
+ Inconsolata: A bit all-around
+ Source code pro: Wide but nice

To show the list of available fonts you can eval
(print (font-family-list))

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)

(set-face-attribute 'default nil
                    :family "Hack"
                    :height 140
                    :weight 'semi-light
                    :width 'normal)
#+END_SRC

Manually setting font for managing Unicode symbols

#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'unicode "Apple Color Emoji" nil 'prepend)
#+END_SRC

** Powerline

Let's powerline.

#+BEGIN_SRC emacs-lisp
(setq ns-use-srgb-colorspace nil) ; Needed to display correctly powerline separators


(set-face-attribute 'mode-line nil
                    :foreground "White"
                    :background "#6E549E"
                    :box nil)

(use-package powerline
  :ensure t
  :config (progn
          (setq powerline-default-separator 'wave)
          (setq powerline-display-hud t)
          (setq powerline-display-buffer-size nil)
          (setq powerline-display-mule-info nil)
          (powerline-center-theme)))
#+END_SRC

** Mouse

Smoother scrolling with mouse. This is the only thing I still miss from Sublime text

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-follow-mouse 't)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC

Scrolling with keyboard before touching bottom.

#+BEGIN_SRC emacs-lisp
(setq redisplay-dont-pause t
      scroll-margin 1
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)

(use-package smooth-scrolling
  :ensure t
  :init (setq smooth-scroll-margin 10))

#+END_SRC

** Buffer listing

Let's use ibuffer for buffer listing

#+BEGIN_SRC emacs-lisp
(defalias 'list-buffers 'ibuffer)
#+END_SRC

** Tab bar

#+BEGIN_SRC emacs-lisp
(use-package tabbar
  :ensure t
  :bind (("C-M-<left>" . tabbar-backward-tab)
         ("C-M-<right>" . tabbar-forward-tab))
  :config (tabbar-mode 1))

(use-package tabbar-ruler
  :ensure t
  :after (tabbar)
  :config (progn
            (setq tabbar-ruler-global-tabbar t)))
#+END_SRC

* Minibuffer

Incremental search in minibuffer

#+BEGIN_SRC emacs-lisp
(iswitchb-mode 1)
#+END_SRC

By default arrow keys do not work in iswitchb
This can solve it

#+BEGIN_SRC emacs-lisp
(defun iswitchb-local-keys ()
  (mapc (lambda (K)
	  (let* ((key (car K)) (fun (cdr K)))
	    (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
	'(("<right>" . iswitchb-next-match)
	  ("<left>"  . iswitchb-prev-match)
	  ("<up>"    . ignore             )
	  ("<down>"  . ignore             ))))
(add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
#+END_SRC

* Keyboard

#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta t)
(setq mac-right-option-modifier nil)
(setq mac-command-modifier 'super)
#+END_SRC

This is not too useful but it is awesome. This makes Fn key in Mac to be Hyper.
I must admit that this is only here so I can make an hyper-space combo.

#+BEGIN_SRC emacs-lisp
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
#+END_SRC

There are some default mac bindings that are annoying to me. I will disable s-P for printing

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-p"))
#+END_SRC

* Mouse in terminal

This takes back mouse and makes it work in a terminal. Commented until I make terminal mode to work as I want.

#+BEGIN_SRC emacs-lisp
(require 'mouse)
(xterm-mouse-mode t)
(defun track-mouse (e))
(setq mouse-sel-mode t)
#+END_SRC

* Manipulating text

This is a small script so ALT key drags lines up and down.

#+BEGIN_SRC emacs-lisp
(use-package move-text
  :ensure t
  :bind (("M-<up>" . move-text-up)
         ("M-<down>" . move-text-down)))
#+END_SRC

Line duplication

#+BEGIN_SRC emacs-lisp
(defun duplicate-line ()
  "Duplicates current line"
  (interactive)
  (let
      ((text-to-insert (thing-at-point 'line)))
    (forward-line 1)
    (insert text-to-insert)
    (forward-line -1)))

(global-set-key (kbd "C-*") 'duplicate-line)

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(global-set-key (kbd "C-c C-e") 'eval-and-replace)
#+END_SRC

I hace ALT-backspace to change my kill ring since I don't often want that there.

#+BEGIN_SRC emacs-lisp
(defun delete-word (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))

(global-set-key (kbd "<M-backspace>") 'delete-word)
#+END_SRC

* Windows

This is a small snippet to move to next or previous windows with C-x p and C-x o

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x p") 'other-window)

(defun other-window-previous (&optional n)
  "Moves to previous window"
  (interactive "p")
  (other-window (if n (- n) -1)))

(global-set-key (kbd "C-x o") 'other-window-previous)
#+END_SRC

Enabling winner mode to restore the configuration of window layout.

#+BEGIN_SRC emacs-lisp
(winner-mode t)
#+END_SRC

* Undo

Much better undo than the default one.

#+BEGIN_SRC emacs-lisp

(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :init
    (progn
      (global-undo-tree-mode 1)
      (defalias 'redo 'undo-tree-redo)

      (global-set-key (kbd "s-z") 'undo)
      (global-set-key (kbd "s-Z") 'redo)))
#+END_SRC

This is binding the visualization to C-s-z but instead of that combo I need to use that strange status number.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-s-268632090>") 'undo-tree-visualize)
#+END_SRC

* Selecting text

Typing over a selection deletes text

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

Expand region key binding.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("s-e" . er/expand-region)))
#+END_SRC

These are multiple cursors bindings.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-d" . mc/mark-next-like-this)
         ("C-S-d" . mc/mark-previous-like-this)
         ("C-M-d" . mc/mark-all-like-this)
         ("H-SPC" . set-rectangular-region-anchor)))
#+END_SRC

* Moving around
** Search

Using phi search for a nice incremental search that allows to go to the search or come back if the search is not what expected.

#+BEGIN_SRC emacs-lisp
(use-package phi-search
  :ensure t
  :bind ("C-s" . phi-search))
#+END_SRC

** Avy jump

Avy jump is great for moving around. I use the new timer version. This was introduced in avy 0.4.0 and it is a really beautiful way of moving around. A combination of classical avy jump + isearch


#+BEGIN_SRC emacs-lisp

(use-package avy
  :ensure t
  :bind ("C-c j" . avy-goto-char-timer))
#+END_SRC

* Open in external editor

A small snippet to open current file in external editor.

TODO: give credit for this.

#+BEGIN_SRC emacs-lisp
(defun open-with (arg)
  "Open visited file in default external program.

With a prefix ARG always prompt for command to use."
  (interactive "P")
  (when buffer-file-name
    (shell-command (concat
                    (cond
                     ((and (not arg) (eq system-type 'darwin)) "open")
                     ((and (not arg) (member system-type '(gnu gnu/linux gnu/kfreebsd))) "xdg-open")
                     (t (read-shell-command "Open current file with: ")))
                    " "
                    (shell-quote-argument buffer-file-name)))))

(global-set-key (kbd "C-c o") 'open-with)
#+END_SRC

* White space handling

Remove trailing whitespace of the file

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* Midnight

#+BEGIN_SRC emacs-lisp
(require 'midnight)
#+END_SRC

Kill buffers if they were last disabled more than this seconds ago

#+BEGIN_SRC emacs-lisp
(setq clean-buffer-list-delay-special 900)

(defvar clean-buffer-list-timer nil
  "Stores clean-buffer-list timer if there is one. You can disable clean-buffer-list by (cancel-timer clean-buffer-list-timer).")

;; run clean-buffer-list every 4 hours
(setq clean-buffer-list-timer (run-at-time t 14400 'clean-buffer-list))

;; kill everything, clean-buffer-list is very intelligent at not killing
;; unsaved buffer.
(setq clean-buffer-list-kill-regexps '("^.*$"))
#+END_SRC

* Backup files

This will create a folder called $HOME/.saves-emacs that will contain all backups.

This is done so we avoid cluttering the folder where the file is being edited

#+BEGIN_SRC emacs-lisp
(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "~/.saves-emacs"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+END_SRC

* Projectile

Enabling projectile for project management

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode "Ⓟ"
  :init (setq projectile-enable-caching nil)
  :config (projectile-global-mode))
#+END_SRC


* Spellchecker

#+BEGIN_SRC emacs-lisp
;; Flyspell
(diminish 'flyspell-mode)

(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
(global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)

(let ((langs '("english" "spanish")))
      (setq lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert lang-ring elem)))

(defun cycle-ispell-languages ()
  (interactive)
  (let ((lang (ring-ref lang-ring -1)))
    (ring-insert lang-ring lang)
    (ispell-change-dictionary lang)))

(ispell-change-dictionary "english")
(setq flyspell-default-dictionary "english")

(global-set-key (kbd "C-S-s-<f8>") 'cycle-ispell-languages)
#+END_SRC

* Org mode

Org mode is one of the most awesome things in emacs.

Binding F7 to open a personal_notes.org file in root of projectile

#+BEGIN_SRC emacs-lisp
(require 'projectile)

(defun projectile-open-personal-notes ()
  "Opens a personal_notes.org file in project folder"
  (interactive)
  (let
      ((folder (car (projectile-get-project-directories))))
    (if folder
      (find-file (concat folder "personal_notes.org"))
      (message "No project folder found"))))

(use-package org
  :ensure t
  :bind (("<f7>" . projectile-open-personal-notes)
         ("C-c c" . org-capture))
  :init (progn
          (setq org-hide-emphasis-markers t)
          (setq org-startup-with-inline-images t)
          (setq org-default-notes-file "~/capture.org"))
          (setq org-capture-templates
                    '(("t" "Todo" entry (file+headline "~/org/tasks.org" "Tasks") "* TODO %?\n  %i\n  %a")
                      ("r" "Retro" entry (file+headline "~/org/retro.org" "Retro") "* %?\nEntered on %U\n  %i\n  %a")
                      ("a" "Agile" entry (file+headline "~/org/agile.org" "Agile") "* %?\nEntered on %U\n  %i\n  %a"))))
#+END_SRC

Org bullets will display bullet points as UTF characters

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

#+END_SRC

The export to HTML of org mode requires htmlize

#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC

Let's configure some languages to run in org-babel mode.

- Ditta: To draw diagrams

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages '(
        (ruby . t)
        (ditaa . t)))

(setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.9/libexec/ditaa0_9.jar")
#+END_SRC

I can never accept code from external sources :P161

#+BEGIN_SRC emacs-lisp
(defun my-org-confirm-babel-evaluate (lang body) nil)
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC

#+RESULTS:
: my-org-confirm-babel-evaluate

* Helm

This is done to solve a bug in MELPA stable helm version. Once this is not needed I should remove this line.

#+BEGIN_SRC emacs-lisp
(defalias 'helm-buffer-match-major-mode 'helm-buffers-list--match-fn)
(defalias 'helm-buffer-match-major-mode 'helm-buffers-match-function)
#+END_SRC

Using projectile mode

#+BEGIN_SRC emacs-lisp
(setq projectile-completion-system 'helm)
(helm-projectile-on)

(global-set-key (kbd "C-c p p") 'helm-projectile-switch-project)
#+END_SRC

Helm bindings to substitute some standard commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x) ; Helm for emacs commands

(setq helm-boring-buffer-regexp-list '("\\*.+\\*" "\*magit"))
(global-set-key (kbd "C-x b") 'helm-buffers-list) ; Helm for buffer list

(global-set-key (kbd "M-y") 'helm-show-kill-ring) ; Helm for kill ring
#+END_SRC

One of my most used bindings. Search in project.

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :bind (("C-p" . helm-projectile-find-file))
  :ensure t)
#+END_SRC

And also we can search in the contents of any file in the current project or the root of the project.

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :bind (("C-f" . helm-do-ag-project-root)
         ("C-S-f" . helm-do-ag))
  :ensure t)
#+END_SRC


* Snippets

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode "Ⓨ "
  :config (progn (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
                 (add-hook 'term-mode-hook (lambda() (setq yas-dont-activate t)))
                 (yas-global-mode 1)))
#+END_SRC

* Programming languages

Globally we will enable electric pair to match parentheses.

#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC

We will globally enable syntax highlight

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :diminish flycheck-mode "✈"
  :config (add-hook 'after-init-hook #'global-flycheck-mode))

#+END_SRC

** Company mode

Company mode is used for autocompletion

I set the delay to 0 to prevent any waiting for the autocompletion popup to show

Usually it is not needed at the start (remember I use emacs daemon).

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :diminish company-mode "Ⓒ"
  :init (global-company-mode)
  :config (progn
                (setq company-idle-delay .3)
                (setq company-echo-delay 0)
                (setq company-tooltip-limit 15)
                (setq company-minimum-prefix-length 1)
                (setq company-dabbrev-downcase nil)))
#+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp
;; (add-hook 'cider-mode-hook #'eldoc-mode)

;; In case of errors with nREPL you can enable this
;; (setq nrepl-log-messages t)

;; Hide cider special buffers
(setq nrepl-hide-special-buffers t)

;; Print a maximum of 100 items per collection
(setq cider-repl-print-length 100)

(setq cider-repl-result-prefix ";; => ")
(setq cider-interactive-eval-result-prefix ";; => ")
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
(add-hook 'haskell-mode-hook 'flycheck-mode)
#+END_SRC

** HTML, templates & CSS

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode (("\\.html?\\'" . web-mode)
         ("\\.html\\.erb\\'" . web-mode))
  :config
    (progn
      (setq web-mode-markup-indent-offset 2)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-enable-auto-pairing t)))
#+END_SRC

Also for SASS

#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t
  :mode (("\\.scss\\'" . scss-mode))
  :config (setq scss-compile-at-save nil))
#+END_SRC

Some projects I do use HAML

#+BEGIN_SRC emacs-lisp
(use-package haml-mode
  :ensure t)
#+END_SRC


** Markdown

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

** Ruby

We will use RVM's provided Ruby

#+BEGIN_SRC emacs-lisp
(use-package rvm
  :ensure t
  :defer t
  :config (rvm-use-default))

#+END_SRC

Adding file types with no rb extension: rake files, irbrc...

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist
	     '("\\.\\(?:gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))

(add-to-list 'auto-mode-alist
               '("\\(Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))


;; Adding syntax checking
;(add-hook 'ruby-mode-hook 'flymake-ruby-load)
(add-hook 'ruby-mode-hook 'yafolding-mode)

(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

(use-package projectile-rails
  :ensure t
  :diminish projectile-rails-mode "RoR "
  :config (add-hook 'projectile-mode-hook 'projectile-rails-on))
#+END_SRC

Use Rubocop for Ruby code linting

#+BEGIN_SRC emacs-lisp
(use-package rubocop
  :ensure t
  :diminish rubocop-mode
  :init (add-hook 'ruby-mode-hook #'rubocop-mode))
#+END_SRC

Project navigation with Robe

#+BEGIN_SRC emacs-lisp
(use-package robe
  :ensure t
  :init (progn
           (add-hook 'ruby-mode-hook 'robe-mode)
           (eval-after-load 'company
              '(push 'company-robe company-backends))
           (defadvice inf-ruby-console-auto (before activate-rvm-for-robe activate)
              (rvm-activate-corresponding-ruby))))
#+END_SRC


** Elixir

#+BEGIN_SRC emacs-lisp

(use-package alchemist
  :ensure t
  :config (setq alchemist-hooks-test-on-save t)
  :bind (("C-c m" . alchemist-mix)))
#+END_SRC

** Javascript

Linting and syntax checking.

Before having it available you need to run

npm install -g eslint babel-eslint eslint-plugin-react


#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :init (setq js-indent-level 4)
  :config (add-hook 'js-mode-hook 'js2-minor-mode))
#+END_SRC

React specific settings

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.json$" . js-mode))
(add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))
#+END_SRC

** Coffeescript

#+BEGIN_SRC emacs-lisp
(use-package coffee-mode
  :ensure t
  :config (custom-set-variables
            '(coffee-tab-width 2)))
#+END_SRC


** Go

Go mode. This will also autoformat after saving following go standards

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :bind ("C-c C-r" . go-remove-unused-imports)
  :config (add-hook 'before-save-hook 'gofmt-before-save))
#+END_SRC


Autocomplete for Go. We will be using company mode too.

#+BEGIN_SRC emacs-lisp
(use-package company-go
  :ensure t
  :config (add-hook 'go-mode-hook (lambda ()
                                    (set (make-local-variable 'company-backends) '(company-go))
                                      (company-mode))))
#+END_SRC

** Elm

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t
  :init (progn
           (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
           (with-eval-after-load 'company
              (add-to-list 'company-backends 'company-elm))))

#+END_SRC

** Rust

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :ensure t)
#+END_SRC

* Puppet

Puppet will use its own mode since Ruby mode can cause some weirdness there.

#+BEGIN_SRC emacs-lisp
(use-package puppet-mode
  :ensure t)
#+END_SRC

* Git

We will use Magit for git. Also opening timemachine is a nice binding to have.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("<f6>" . magit-status)))
#+END_SRC

Time machine is a nice package to browse the story of a file

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :bind (("C-<f6>" . git-timemachine)))

#+END_SRC

Also for some projects it is nice to be able to browse the file on Github.

#+BEGIN_SRC emacs-lisp
(use-package github-browse-file
  :ensure t
  :bind (("C-c g f" . github-browse-file)))
#+END_SRC

And let's put a nice gutter

#+BEGIN_SRC emacs-lisp
;(use-package git-gutter
;  :ensure t
;  :init (progn
;           (global-git-gutter-mode t)
;           (git-gutter:linum-setup)
;            (custom-set-variables
;              '(git-gutter:update-interval 2))))
#+END_SRC


* Docker

Emacs is great for managing docker images. Also I will use the syntax help for Dockerfiles

#+BEGIN_SRC emacs-lisp
(use-package docker
  :ensure t)

(use-package dockerfile-mode
  :ensure t
  :config (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

#+END_SRC


* Help and documentation

** Guide key

When I start typing a combo a help with the possible continuations appear if I wait for a while.

#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :ensure t
  :diminish guide-key-mode
  :init (setq guide-key/guide-key-sequence t)
  :config (guide-key-mode 1))
#+END_SRC

** Dash

Integration with Dash

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/vendor/dash-at-point")
(autoload 'dash-at-point "dash-at-point"
  "Search the word at point with Dash." t nil)
(global-set-key "\C-cd" 'dash-at-point)
(global-set-key "\C-ce" 'dash-at-point-with-docset)
#+END_SRC

* File navigation
** Neo tree

#+BEGIN_SRC emacs-lisp
(defun neotree-to-root ()
  "Moves neotree to root of project"
  (interactive)

  (let ((git-folder (car (projectile-get-project-directories))))
                              (neotree-dir git-folder)))

(use-package neotree
  :ensure t
  :bind ("<C-tab>" . neotree-toggle))
#+END_SRC

** Dired

Making dired to open the file in the current buffer instead of opening a new one

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

Dired likes gnu ls more than ls in osx so let's make it use it

#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program t)
(setq insert-directory-program "gls")
#+END_SRC

* Keyfreq

This is just for measuring the frequency for the commands run

#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :ensure t
  :init (progn
          (keyfreq-mode 1)
          (keyfreq-autosave-mode 1)
          (setq keyfreq-excluded-commands
            '(self-insert-command
              abort-recursive-edit
              previous-line
              next-line))))
#+END_SRC

* Applications
** Email

We need to install mu with emacs support in OsX with

EMACS=$(which emacs) brew install mu --with-emacs --HEAD

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f1>") 'mu4e)

(setq mu4e-maildir "~/.Maildir")
(require 'mu4e)
(setq mu4e-get-mail-command "offlineimap")
(setq message-kill-buffer-on-exit t)

(setq mu4e-contexts
    `( ,(make-mu4e-context
	  :name "Personal"
	  :enter-func (lambda () (mu4e-message "Switch to the Personal context"))
	  ;; leave-func not defined
	  :match-func (lambda (msg)
			(when msg
			  (mu4e-message-contact-field-matches msg
			    :to "rafael@micubiculo.com")))
	  :vars '(  ( user-mail-address	     . "rafael@micubiculo.com"  )
		   ( user-full-name	    . "Rafa de Castro" )
		   ( mu4e-compose-signature .
		     (concat
		       "Rafa de Castro\n"
		       "http://joy.pm\n"))
                   (mu4e-drafts-folder . "/Personal/[Google Mail].Drafts")
                   (mu4e-sent-folder   . "/Personal/[Google Mail].Sent Mail")
                   (mu4e-trash-folder  . "/Personal/[Google Mail].Bin")))
       ,(make-mu4e-context
	  :name "Work"
	  :enter-func (lambda () (mu4e-message "Switch to the Work context"))
	  ;; leave-fun not defined
	  :match-func (lambda (msg)
			(when msg
			  (mu4e-message-contact-field-matches msg
			    :to "rafael.decastro@platform161.com")))
	  :vars '( ( user-mail-address	     . "rafael.decastro@platform161.com" )
		   ( user-full-name	    . "Rafael de Castro" )
		   ( mu4e-compose-signature .
		     (concat
		       "Rafael de Castro\n"))
                   (mu4e-drafts-folder . "/Work/[Gmail].Drafts")
                   (mu4e-sent-folder   . "/Work/[Gmail].Sent Mail")
                   (mu4e-trash-folder  . "/Work/[Gmail].Bin")))))
#+END_SRC


** RSS reader

I use elfeed to read RSS. It can be configured via and org mode file. Extra awesomeness!

#+BEGIN_SRC emacs-lisp

(defun elfeed-feeds ()
  "Open the elfeed feeds file"
  (interactive)
  (find-file "~/.emacs.d/elfeed/elfeed.org"))

(use-package elfeed
  :ensure t
  :init (progn
          (use-package elfeed-org
              :ensure t
              :init (progn
                      (elfeed-org)
                      (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed/elfeed.org"))
                      (setq elfeed-use-curl t))
                      (setf url-queue-timeout 30)))
  :bind (("<f2>" . elfeed)))

#+END_SRC


* Some general purpose functions

These are some general functions that are useful and have no better place to be in

** Copy file to clipboard

Copies the file to the clipboard.

#+BEGIN_SRC emacs-lisp
(defun current_buffer_file_name ()
  (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))

(defun copy-path-to-clipboard ()
  "Copy the current buffer full file path to the clipboard."
  (interactive)
  (let ((filename (current_buffer_file_name)))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(defun copy-filename-to-clipboard ()
  "Copy the current buffer file name relative to projectile root to the clipboard."
  (interactive)
  (let* ((base_path (car (projectile-get-project-directories)))
         (filename (replace-regexp-in-string base_path "" (current_buffer_file_name))))
     (when filename
       (kill-new filename)
       (message "Copied buffer file name '%s' to the clipboard." filename))))

#+END_SRC

** Chrome reload

This function just reloads chrome. This is useful to avoid too much alt-tab

#+BEGIN_SRC emacs-lisp
(defun chrome-reload ()
  "Reloads current chrome window"
  (interactive)
  (shell-command "chrome-cli reload"))

(define-prefix-command 'manage-browser-map)
(global-set-key (kbd "C-b") 'manage-browser-map)

(defun chrome-reload ()
  "Reloads current chrome window"
  (interactive)
  (shell-command "chrome-cli reload"))

(define-key manage-browser-map "r" 'chrome-reload)
#+END_SRC

* Custom scripts

These are scripts that are worthy of their own source file and I'm not including them here.

#+BEGIN_SRC emacs-lisp
(use-package copy-rtf
  :load-path "src/copy-rtf")

(use-package p161-mode
  :load-path "src/p161-mode"
  :bind (("C-c t" . send-test-to-tmux)
         ("C-c C-p b" . open-current-ticket-in-browser))
;  :init (add-hook 'git-commit-mode-hook 'insert-pfm-in-commit-message)
  )

(defun turn-on-p161-mode-hook ()
  (cond ((string-match "^//Users/rafael/code/platform161/" buffer-file-name)
         (p161-mode 1))))

; (add-hook 'text-mode-hook 'turn-on-p161-mode-hook)

(load-file "~/.emacs.d/src/emacs-presentation-mode/emacs-presentation-mode.el")
#+END_SRC
