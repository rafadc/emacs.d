+TITLE:   Rafa's Emacs settings file
#+AUTHOR:  Rafa de Castro
#+EMAIL:   rafael@micubiculo.com
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

To use this change your init file for something like

#+BEGIN_SRC
(require 'org)
(org-babel-load-file
 (expand-file-name "settings.org"
                   user-emacs-directory))
#+END_SRC

Then you will only have your org file to handle all your emacs configuration. It may sound overkill in the beginning. I'm testing this too ;)

At this moment all features are in external el files. I'm migrating from those to this dile only so there are some *load-file*s out there yet.

* Use package

Bootstrapping use-package. This looks for use package in the system ans installs it if it is not there. This is the only package we need to install this way.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC


* Editing settings

I'll add a function to edit settings.org file. I don't need a shortcut since this is not such a common task now.

#+BEGIN_SRC emacs-lisp
(defun settings ()
  "Edits settings.org file"
  (interactive)
  (find-file "~/.emacs.d/settings.org"))
#+END_SRC

* Visuals

Use spaces instead of tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Nothing bigger than 80 lines. This is nice also for code. ;). Anyway we can avoid the org node since this may make sense for longer texts.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :diminish whitespace-mode
  :config (progn (setq whitespace-line-column 120)
                 (setq whitespace-style '(face empty tabs lines-tail trailing))
                 (setq whitespace-global-modes '(not org-mode web-mode "Web" emacs-lisp-mode))
                 (global-whitespace-mode t)))
#+END_SRC

The theme is based on base16 color set

#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/themes/base16-emacs/base16-default-theme.el")
#+END_SRC

But the dark theme colors are cooler

#+BEGIN_SRC emacs-lisp
(sml/setup)
(sml/apply-theme 'dark)
#+END_SRC

Disable menu and icon bar

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC

Show full path of file in status bar

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '(:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) "%b")))
#+END_SRC

Show line numbers

#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
#+END_SRC

Paren highlight
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Font. I like a ton of different fonts and I use them a lot. My choices are:

+ Hermit / light: Playful. Coding must be fun.
+ M+ 1mn / light: When you are feeling professional
+ Input Mono Compressed: Somewhat old school but really readable.
+ Inconsolata: A bit all-around

To show the list of available fonts you can eval
(print (font-family-list))

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'default nil
                    :family "Inconsolata" :height 210 :weight 'light)
#+END_SRC

Smoother scrolling with mouse. This is the only thing I still miss from Sublime text

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-follow-mouse 't)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC

Scrolling with keyboard before touching bottom

#+BEGIN_SRC emacs-lisp
(setq redisplay-dont-pause t
      scroll-margin 1
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)
#+END_SRC

Asking y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

* Minibuffer

Incremental search in minibuffer

#+BEGIN_SRC emacs-lisp
(iswitchb-mode 1)
#+END_SRC

By default arrow keys do not work in iswitchb
This can solve it

#+BEGIN_SRC emacs-lisp
(defun iswitchb-local-keys ()
  (mapc (lambda (K)
	  (let* ((key (car K)) (fun (cdr K)))
	    (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
	'(("<right>" . iswitchb-next-match)
	  ("<left>"  . iswitchb-prev-match)
	  ("<up>"    . ignore             )
	  ("<down>"  . ignore             ))))
(add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
#+END_SRC

* Keyboard

#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta t)
(setq mac-right-option-modifier nil)
(setq mac-command-modifier 'super)
#+END_SRC

This is not too useful but it is awesome. This makes Fn key in Mac to be Hyper.
I must admit that this is only here so I can make an hyper-space combo.

#+BEGIN_SRC emacs-lisp
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
#+END_SRC

There are some default mac bindings that are annoying to me. I will disable s-P for printing

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-p"))
#+END_SRC

* Mouse in terminal

This takes back mouse and makes it work in a terminal. Commented until I make terminal mode to work as I want.

#+BEGIN_SRC emacs-lisp
;(require 'mouse)
;(xterm-mouse-mode t)
;(defun track-mouse (e))
;(setq mouse-sel-mode t)
#+END_SRC

* Manipulating text

This is a small script so ALT key drags lines up and down.

#+BEGIN_SRC emacs-lisp
(defun grab-line-down ()
  "Moves current line down"
  (interactive)
  (progn
   (forward-line 1)
   (transpose-lines 1)
   (forward-line -1)))

(defun grab-line-up ()
  "Moves current line up"
  (interactive)
  (progn
   (forward-line 1)
   (transpose-lines -1)
   (forward-line -2)))

(global-set-key (kbd "M-<down>") 'grab-line-down)
(global-set-key (kbd "M-<up>") 'grab-line-up)

(defun duplicate-line ()
  "Duplicates current line"
  (interactive)
  (let
      ((text-to-insert (thing-at-point 'line)))
    (forward-line 1)
    (insert text-to-insert)
    (forward-line -1)))

(global-set-key (kbd "s-*") 'duplicate-line)

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(global-set-key (kbd "C-c C-e") 'eval-and-replace)
#+END_SRC

I hace ALT-backspace to change my kill ring since I don't often want that there.

#+BEGIN_SRC emacs-lisp
(defun delete-word (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))

(global-set-key (kbd "<M-backspace>") 'delete-word)
#+END_SRC

* Windows

This is a small snippet to move to next or previous windows with C-x p and C-x o

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x p") 'other-window)

(defun other-window-previous (&optional n)
  "Moves to previous window"
  (interactive "p")
  (other-window (if n (- n) -1)))

(global-set-key (kbd "C-x o") 'other-window-previous)
#+END_SRC

Enabling winner mode to restore the configuration of window layout.

#+BEGIN_SRC emacs-lisp
(winner-mode t)
#+END_SRC

* Undo

Much better undo than the default one.

#+BEGIN_SRC emacs-lisp

(use-package undo-tree
  :ensure t
  :init
    (progn
      (global-undo-tree-mode 1)
      (defalias 'redo 'undo-tree-redo)

      (global-set-key (kbd "s-z") 'undo)
      (global-set-key (kbd "s-Z") 'redo)))
#+END_SRC

This is binding the visualization to C-s-z but instead of that combo I need to use that strange status number.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-s-268632090>") 'undo-tree-visualize)
#+END_SRC

* Selecting text

Typing over a selection deletes text

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

Expand region key binding.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("s-e" . er/expand-region)))
#+END_SRC

These are multiple cursors bindings.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-d" . mc/mark-next-like-this)
         ("C-S-d" . mc/mark-previous-like-this)
         ("C-M-d" . mc/mark-all-like-this)
         ("H-SPC" . set-rectangular-region-anchor)))
#+END_SRC

* Moving around
** Search

Using phi search for a nice incremental search that allows to go to the search or come back if the search is not what expected.

#+BEGIN_SRC emacs-lisp
(use-package phi-search
  :ensure t
  :bind ("C-s" . phi-search))
#+END_SRC

** Avy jump

Avy jump is great for moving around.

#+BEGIN_SRC emacs-lisp

(use-package avy
  :ensure t
  :bind ("C-c j" . avy-goto-char))
#+END_SRC

* Open in external editor

A small snippet to open current file in external editor.

TODO: give credit for this.

#+BEGIN_SRC emacs-lisp
(defun open-with (arg)
  "Open visited file in default external program.

With a prefix ARG always prompt for command to use."
  (interactive "P")
  (when buffer-file-name
    (shell-command (concat
                    (cond
                     ((and (not arg) (eq system-type 'darwin)) "open")
                     ((and (not arg) (member system-type '(gnu gnu/linux gnu/kfreebsd))) "xdg-open")
                     (t (read-shell-command "Open current file with: ")))
                    " "
                    (shell-quote-argument buffer-file-name)))))

(global-set-key (kbd "C-c o") 'open-with)
#+END_SRC

* White space handling

Remove trailing whitespace of the file

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* Midnight

#+BEGIN_SRC emacs-lisp
(require 'midnight)
#+END_SRC

Kill buffers if they were last disabled more than this seconds ago

#+BEGIN_SRC emacs-lisp
(setq clean-buffer-list-delay-special 900)

(defvar clean-buffer-list-timer nil
  "Stores clean-buffer-list timer if there is one. You can disable clean-buffer-list by (cancel-timer clean-buffer-list-timer).")

;; run clean-buffer-list every 4 hours
(setq clean-buffer-list-timer (run-at-time t 14400 'clean-buffer-list))

;; kill everything, clean-buffer-list is very intelligent at not killing
;; unsaved buffer.
(setq clean-buffer-list-kill-regexps '("^.*$"))
#+END_SRC

* Backup files

This will create a folder called $HOME/.saves-emacs that will contain all backups.

This is done so we avoid cluttering the folder where the file is being edited

#+BEGIN_SRC emacs-lisp
(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "~/.saves-emacs"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+END_SRC

* Spellchecker

#+BEGIN_SRC emacs-lisp
;; Flyspell
(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
(global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)

(let ((langs '("english" "spanish")))
      (setq lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert lang-ring elem)))

(defun cycle-ispell-languages ()
  (interactive)
  (let ((lang (ring-ref lang-ring -1)))
    (ring-insert lang-ring lang)
    (ispell-change-dictionary lang)))

(ispell-change-dictionary "english")
(setq flyspell-default-dictionary "english")

(global-set-key (kbd "C-S-s-<f8>") 'cycle-ispell-languages)
#+END_SRC

* Org mode

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure t)

;; Binding F7 to open a personal_notes.org file in root of projectile
(require 'projectile)

(defun projectile-open-personal-notes ()
  "Opens a personal_notes.org file in project folder"
  (interactive)
  (let
      ((folder (car (projectile-get-project-directories))))
    (if folder
      (find-file (concat folder "personal_notes.org"))
      (message "No project folder found"))))

(global-set-key (kbd "<f7>") 'projectile-open-personal-notes)
#+END_SRC

* Helm

This is done to solve a bug in MELPA stable helm version. Once this is not needed I should remove this line.

#+BEGIN_SRC emacs-lisp
(defalias 'helm-buffer-match-major-mode 'helm-buffers-list--match-fn)
(defalias 'helm-buffer-match-major-mode 'helm-buffers-match-function)
#+END_SRC

Helm bindings to substitute some standard commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x) ; Helm for emacs commands

(global-set-key (kbd "C-x b") 'helm-buffers-list) ; Helm for buffer list

(global-set-key (kbd "M-y") 'helm-show-kill-ring) ; Helm for kill ring

(global-set-key (kbd "C-p") 'helm-projectile)

(global-set-key (kbd "C-F") 'helm-do-ag)
#+END_SRC

* Company mode

I set the delay to 0 to prevent any waiting for the autocompletion popup to show

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-company-mode)
(setq company-idle-delay 0)
#+END_SRC

* Snippets

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config (progn (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
                 (yas-global-mode 1)))
#+END_SRC

* Programming languages

** Clojure

#+BEGIN_SRC emacs-lisp
;; (add-hook 'cider-mode-hook #'eldoc-mode)

;; In case of errors with nREPL you can enable this
;; (setq nrepl-log-messages t)

;; Hide cider special buffers
(setq nrepl-hide-special-buffers t)

;; Print a maximum of 100 items per collection
(setq cider-repl-print-length 100)

(setq cider-repl-result-prefix ";; => ")
(setq cider-interactive-eval-result-prefix ";; => ")
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
(add-hook 'haskell-mode-hook 'flycheck-mode)
#+END_SRC

** HTML & CSS

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode (("\\.html?\\'" . web-mode)
         ("\\.html\\.erb\\'" . web-mode))
  :config
    (progn
      (setq web-mode-markup-indent-offset 2)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-enable-auto-pairing t)))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

** Ruby

Adding file types with no rb extension

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist
	     '("\\.\\(?:gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))

(add-to-list 'auto-mode-alist
               '("\\(Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))


;; Adding syntax checking
(add-hook 'ruby-mode-hook 'flymake-ruby-load)
(add-hook 'ruby-mode-hook 'flymake-cursor-mode)
(add-hook 'ruby-mode-hook 'yafolding-mode)

(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

;; Projectile rails mode
(add-hook 'projectile-mode-hook 'projectile-rails-on)
#+END_SRC

** Elixir

#+BEGIN_SRC emacs-lisp

(use-package alchemist
  :ensure t
  :config (setq alchemist-hooks-test-on-save t))
#+END_SRC


* Git

We will use Magit for git. Also opening timemachine is a nice binding to have.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("<f6>" . magit-status)))

(use-package git-timemachine
  :ensure t
  :bind (("C-<f6>" . git-timemachine)))

#+END_SRC

* Unmanaged scripts

These are stand alone scripts I don't want in this config file.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/unmanaged/nyan-mode")
(load "nyan-mode.el")
(nyan-mode +1)

(add-to-list 'load-path "~/.emacs.d/unmanaged/restclient")
(require 'restclient)

(add-to-list 'load-path "~/.emacs.d/unmanaged/hl-line+")
(require 'hl-line+)

#+END_SRC

There is a problem with MELPA stable projectile helm version. It is outdated and seems to be broken. Until they fix it I have the latest here

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/unmanaged/helm-projectile")
(require 'helm-projectile)
#+END_SRC

* Help and documentation

** Guide key

When I start typing a combo a help with the possible continuations appear if I wait for a while.

#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence t)
(guide-key-mode 1)
#+END_SRC

** Dash

Integration with Dash

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/unmanaged/dash-at-point")
(autoload 'dash-at-point "dash-at-point"
  "Search the word at point with Dash." t nil)
(global-set-key "\C-cd" 'dash-at-point)
(global-set-key "\C-ce" 'dash-at-point-with-docset)
#+END_SRC

* File navigation
** Neo tree

#+BEGIN_SRC emacs-lisp
(defun neotree-to-root ()
  "Toggles neotree moving to root of project"
  (interactive)

  (if (neo-global--window-exists-p)
    (neotree-hide)
    (let ((git-folder (car (projectile-get-project-directories))))
                              (neotree-dir git-folder))))

(use-package neotree
  :ensure t
  :bind ("<C-tab>" . neotree-to-root)
  :init (setq projectile-switch-project-action 'neotree-projectile-action))
#+END_SRC

** Dired

Making dired to open the file in the current buffer instead of opening a new one

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC


* Applications
** RSS reader

I use elfeed to read RSS

#+BEGIN_SRC emacs-lisp

(use-package elfeed
  :ensure t
  :init (progn
          (load-file "~/.emacs.d/elfeed/feeds.el")
          (setf url-queue-timeout 30)))

#+END_SRC


* Some general purpose functions

These are some general functions that are useful and have no better place to be in

** Copy file to clipboard

Copies the file to the clipboard.

#+BEGIN_SRC emacs-lisp
(defun current_buffer_file_name ()
  (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))

(defun copy-path-to-clipboard ()
  "Copy the current buffer full file path to the clipboard."
  (interactive)
  (let ((filename (current_buffer_file_name)))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(defun copy-filename-to-clipboard ()
  "Copy the current buffer file name relative to projectile root to the clipboard."
  (interactive)
  (let* ((base_path (car (projectile-get-project-directories)))
         (filename (replace-regexp-in-string base_path "" (current_buffer_file_name))))
     (when filename
       (kill-new filename)
       (message "Copied buffer file name '%s' to the clipboard." filename))))

#+END_SRC

** Chrome reload

This function just reloads chrome. This is useful to avoid too much alt-tab

#+BEGIN_SRC emacs-lisp
(defun chrome-reload ()
  "Reloads current chrome window"
  (interactive)
  (shell-command "chrome-cli reload"))

(define-prefix-command 'manage-browser-map)
(global-set-key (kbd "C-b") 'manage-browser-map)

(defun chrome-reload ()
  "Reloads current chrome window"
  (interactive)
  (shell-command "chrome-cli reload"))

(define-key manage-browser-map "r" 'chrome-reload)
#+END_SRC

* Custom scripts

These are scripts that are worthy of their own source file and I'm not including them here.

#+BEGIN_SRC emacs-lisp
(load-file "~/.emacs.d/src/copy-rtf/copy-rtf.el")

(load-file "~/.emacs.d/src/p161-mode/p161-mode.el")
#+END_SRC
