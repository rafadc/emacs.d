#+TITLE:   Rafa's Emacs settings file
#+AUTHOR:  Rafa de Castro
#+EMAIL:   rafael@micubiculo.com
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

[[file:emacs-logo.png]]

To use this change your init file for something like

#+BEGIN_SRC
(require 'org)
(org-babel-load-file
 (expand-file-name "settings.org"
                   user-emacs-directory))
#+END_SRC

Then you will only have your org file to handle all your emacs configuration. It may sound overkill in the beginning. I'm testing this too ;)

At this moment all features are in external el files. I'm migrating from those to this dile only so there are some *load-file*s out there yet.

* Use package

Bootstrapping use-package. This looks for use package in the system ans installs it if it is not there. This is the only package we need to install this way.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+END_SRC

* Environment from shell

Copy the environment variables from shell's environment

#+BEGIN_SRC emacs-lisp

(use-package exec-path-from-shell
  :ensure t
  :config (when (memq window-system '(mac ns))
            (exec-path-from-shell-initialize)))
#+END_SRC


* Scratch buffer

We need to customize the scratch buffer. No particular reason.

#+BEGIN_SRC
(setq initial-scratch-message ";; Beware of the emacs church")
#+END_SRC


* Editing settings

I'll add a function to edit settings.org file. I don't need a shortcut since this is not such a common task now.

#+BEGIN_SRC emacs-lisp
(defun settings ()
  "Edits settings.org file"
  (interactive)
  (find-file "~/.emacs.d/settings.org"))
#+END_SRC

* Visuals

Use spaces instead of tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Nothing bigger than 80 lines. This is nice also for code. ;). Anyway we can avoid the org node since this may make sense for longer texts.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure t
  :diminish whitespace-mode
  :config (progn (setq whitespace-line-column 120)
                 (setq whitespace-style '(face empty tabs lines-tail trailing))
                 (setq whitespace-global-modes '(not org-mode web-mode "Web" emacs-lisp-mode))
                 (global-whitespace-mode t)))
#+END_SRC

I know I know. Too cyberpunk but is is nice sometimes :D

#+BEGIN_SRC emacs-lisp
;(load-file "~/.emacs.d/themes/base16-emacs/base16-default-theme.el")
(use-package cyberpunk-theme
  :ensure t
  :init (add-hook 'after-init-hook
             (lambda () (load-theme 'cyberpunk t))))


#+END_SRC

I'll use a smart-mode-line. A powerline replacement.

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :init (progn
          (sml/setup)
          (sml/apply-theme 'dark)))

#+END_SRC

Disable menu and icon bar

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC

Show full path of file in status bar

#+BEGIN_SRC emacs-lisp
(setq frame-title-format '(:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) "%b")))
#+END_SRC

Show line numbers

#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
#+END_SRC

Paren highlight
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

Font. I like a ton of different fonts and I use them a lot. My choices are:

+ Hermit / light: Playful. Coding must be fun.
+ M+ 1mn / light: When you are feeling professional
+ Input Mono Compressed: Somewhat old school but really readable.
+ Inconsolata: A bit all-around
+ Source code pro: Wide but nice

To show the list of available fonts you can eval
(print (font-family-list))

#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)

(set-face-attribute 'default nil
                    :family "Source Code Pro"
                    :height 160
                    :weight 'semi-light
                    :width 'normal)
#+END_SRC

Manually setting font for managing Unicode symbols

#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'unicode "Apple Color Emoji" nil 'prepend)
#+END_SRC



Smoother scrolling with mouse. This is the only thing I still miss from Sublime text

#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-follow-mouse 't)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
#+END_SRC

Scrolling with keyboard before touching bottom.

#+BEGIN_SRC emacs-lisp
(setq redisplay-dont-pause t
      scroll-margin 1
      scroll-step 1
      scroll-conservatively 10000
      scroll-preserve-screen-position 1)

(use-package smooth-scrolling
  :ensure t
  :init (setq smooth-scroll-margin 10))

#+END_SRC

Asking y/n instead of yes/no

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

For extra nyanness

#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :ensure t
  :init (nyan-mode +1))
#+END_SRC

We will use rainbow delimiters when possible

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC


Highlight current line

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC


* Minibuffer

Incremental search in minibuffer

#+BEGIN_SRC emacs-lisp
(iswitchb-mode 1)
#+END_SRC

By default arrow keys do not work in iswitchb
This can solve it

#+BEGIN_SRC emacs-lisp
(defun iswitchb-local-keys ()
  (mapc (lambda (K)
	  (let* ((key (car K)) (fun (cdr K)))
	    (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
	'(("<right>" . iswitchb-next-match)
	  ("<left>"  . iswitchb-prev-match)
	  ("<up>"    . ignore             )
	  ("<down>"  . ignore             ))))
(add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)
#+END_SRC

* Keyboard

#+BEGIN_SRC emacs-lisp
(setq mac-option-key-is-meta t)
(setq mac-right-option-modifier nil)
(setq mac-command-modifier 'super)
#+END_SRC

This is not too useful but it is awesome. This makes Fn key in Mac to be Hyper.
I must admit that this is only here so I can make an hyper-space combo.

#+BEGIN_SRC emacs-lisp
(setq ns-function-modifier 'hyper)  ; make Fn key do Hyper
#+END_SRC

There are some default mac bindings that are annoying to me. I will disable s-P for printing

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-p"))
#+END_SRC

* Mouse in terminal

This takes back mouse and makes it work in a terminal. Commented until I make terminal mode to work as I want.

#+BEGIN_SRC emacs-lisp
;(require 'mouse)
;(xterm-mouse-mode t)
;(defun track-mouse (e))
;(setq mouse-sel-mode t)
#+END_SRC

* Manipulating text

This is a small script so ALT key drags lines up and down.

#+BEGIN_SRC emacs-lisp
(defun grab-line-down ()
  "Moves current line down"
  (interactive)
  (progn
   (forward-line 1)
   (transpose-lines 1)
   (forward-line -1)))

(defun grab-line-up ()
  "Moves current line up"
  (interactive)
  (progn
   (forward-line 1)
   (transpose-lines -1)
   (forward-line -2)))

(global-set-key (kbd "M-<down>") 'grab-line-down)
(global-set-key (kbd "M-<up>") 'grab-line-up)

(defun duplicate-line ()
  "Duplicates current line"
  (interactive)
  (let
      ((text-to-insert (thing-at-point 'line)))
    (forward-line 1)
    (insert text-to-insert)
    (forward-line -1)))

(global-set-key (kbd "s-*") 'duplicate-line)

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(global-set-key (kbd "C-c C-e") 'eval-and-replace)
#+END_SRC

I hace ALT-backspace to change my kill ring since I don't often want that there.

#+BEGIN_SRC emacs-lisp
(defun delete-word (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (backward-word arg) (point))))

(global-set-key (kbd "<M-backspace>") 'delete-word)
#+END_SRC

* Windows

This is a small snippet to move to next or previous windows with C-x p and C-x o

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x p") 'other-window)

(defun other-window-previous (&optional n)
  "Moves to previous window"
  (interactive "p")
  (other-window (if n (- n) -1)))

(global-set-key (kbd "C-x o") 'other-window-previous)
#+END_SRC

Enabling winner mode to restore the configuration of window layout.

#+BEGIN_SRC emacs-lisp
(winner-mode t)
#+END_SRC

* Undo

Much better undo than the default one.

#+BEGIN_SRC emacs-lisp

(use-package undo-tree
  :ensure t
  :init
    (progn
      (global-undo-tree-mode 1)
      (defalias 'redo 'undo-tree-redo)

      (global-set-key (kbd "s-z") 'undo)
      (global-set-key (kbd "s-Z") 'redo)))
#+END_SRC

This is binding the visualization to C-s-z but instead of that combo I need to use that strange status number.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-s-268632090>") 'undo-tree-visualize)
#+END_SRC

* Selecting text

Typing over a selection deletes text

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

Expand region key binding.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("s-e" . er/expand-region)))
#+END_SRC

These are multiple cursors bindings.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-d" . mc/mark-next-like-this)
         ("C-S-d" . mc/mark-previous-like-this)
         ("C-M-d" . mc/mark-all-like-this)
         ("H-SPC" . set-rectangular-region-anchor)))
#+END_SRC

* Moving around
** Search

Using phi search for a nice incremental search that allows to go to the search or come back if the search is not what expected.

#+BEGIN_SRC emacs-lisp
(use-package phi-search
  :ensure t
  :bind ("C-s" . phi-search))
#+END_SRC

** Avy jump

Avy jump is great for moving around. I use the new timer version. This was introduced in avy 0.4.0 and it is a really beautiful way of moving around. A combination of classical avy jump + isearch


#+BEGIN_SRC emacs-lisp

(use-package avy
  :ensure t
  :bind ("C-c j" . avy-goto-char-timer))
#+END_SRC

* Open in external editor

A small snippet to open current file in external editor.

TODO: give credit for this.

#+BEGIN_SRC emacs-lisp
(defun open-with (arg)
  "Open visited file in default external program.

With a prefix ARG always prompt for command to use."
  (interactive "P")
  (when buffer-file-name
    (shell-command (concat
                    (cond
                     ((and (not arg) (eq system-type 'darwin)) "open")
                     ((and (not arg) (member system-type '(gnu gnu/linux gnu/kfreebsd))) "xdg-open")
                     (t (read-shell-command "Open current file with: ")))
                    " "
                    (shell-quote-argument buffer-file-name)))))

(global-set-key (kbd "C-c o") 'open-with)
#+END_SRC

* White space handling

Remove trailing whitespace of the file

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* Midnight

#+BEGIN_SRC emacs-lisp
(require 'midnight)
#+END_SRC

Kill buffers if they were last disabled more than this seconds ago

#+BEGIN_SRC emacs-lisp
(setq clean-buffer-list-delay-special 900)

(defvar clean-buffer-list-timer nil
  "Stores clean-buffer-list timer if there is one. You can disable clean-buffer-list by (cancel-timer clean-buffer-list-timer).")

;; run clean-buffer-list every 4 hours
(setq clean-buffer-list-timer (run-at-time t 14400 'clean-buffer-list))

;; kill everything, clean-buffer-list is very intelligent at not killing
;; unsaved buffer.
(setq clean-buffer-list-kill-regexps '("^.*$"))
#+END_SRC

* Backup files

This will create a folder called $HOME/.saves-emacs that will contain all backups.

This is done so we avoid cluttering the folder where the file is being edited

#+BEGIN_SRC emacs-lisp
(setq
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist
    '(("." . "~/.saves-emacs"))    ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)       ; use versioned backups
#+END_SRC

* Projectile

Enabling projectile for project management

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init (setq projectile-enable-caching nil)
  :config (projectile-global-mode))
#+END_SRC


* Spellchecker

#+BEGIN_SRC emacs-lisp
;; Flyspell
(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "C-S-<f8>") 'flyspell-mode)
(global-set-key (kbd "C-M-<f8>") 'flyspell-buffer)

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)

(let ((langs '("english" "spanish")))
      (setq lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert lang-ring elem)))

(defun cycle-ispell-languages ()
  (interactive)
  (let ((lang (ring-ref lang-ring -1)))
    (ring-insert lang-ring lang)
    (ispell-change-dictionary lang)))

(ispell-change-dictionary "english")
(setq flyspell-default-dictionary "english")

(global-set-key (kbd "C-S-s-<f8>") 'cycle-ispell-languages)
#+END_SRC

* Org mode

Org mode is one of the most awesome things in emacs.

Binding F7 to open a personal_notes.org file in root of projectile

#+BEGIN_SRC emacs-lisp
(require 'projectile)

(defun projectile-open-personal-notes ()
  "Opens a personal_notes.org file in project folder"
  (interactive)
  (let
      ((folder (car (projectile-get-project-directories))))
    (if folder
      (find-file (concat folder "personal_notes.org"))
      (message "No project folder found"))))

(use-package org
  :ensure t
  :bind (("<f7>" . projectile-open-personal-notes)
         ("C-c c" . org-capture))
  :init (progn
          (setq org-hide-emphasis-markers t)
          (setq org-startup-with-inline-images t)
          (setq org-default-notes-file "~/capture.org"))
          (setq org-capture-templates
                    '(("t" "Todo" entry (file+headline "~/org/tasks.org" "Tasks") "* TODO %?\n  %i\n  %a")
                      ("r" "Retro" entry (file+datetree "~/org/retro.org") "* %?\nEntered on %U\n  %i\n  %a"))))
#+END_SRC

Org bullets will display bullet points as UTF characters

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

#+END_SRC

* Helm

This is done to solve a bug in MELPA stable helm version. Once this is not needed I should remove this line.

#+BEGIN_SRC emacs-lisp
(defalias 'helm-buffer-match-major-mode 'helm-buffers-list--match-fn)
(defalias 'helm-buffer-match-major-mode 'helm-buffers-match-function)
#+END_SRC

Using projectile mode

#+BEGIN_SRC emacs-lisp
(setq projectile-completion-system 'helm)
(helm-projectile-on)

(global-set-key (kbd "C-c p p") 'helm-projectile-switch-project)
#+END_SRC

Helm bindings to substitute some standard commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x) ; Helm for emacs commands

(setq helm-boring-buffer-regexp-list '("\\*.+\\*" "\*magit"))
(global-set-key (kbd "C-x b") 'helm-buffers-list) ; Helm for buffer list

(global-set-key (kbd "M-y") 'helm-show-kill-ring) ; Helm for kill ring
#+END_SRC

One of my most used bindings. Search in project.

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :bind (("C-p" . helm-projectile-find-file))
  :ensure t)
#+END_SRC

And also we can search in the contents of any file in the current project or the root of the project.

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :bind (("C-f" . helm-do-ag-project-root)
         ("C-S-f" . helm-do-ag))
  :ensure t)
#+END_SRC


* Snippets

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config (progn (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
                 (yas-global-mode 1)))
#+END_SRC

* Programming languages

Globally we will enable electric pair to match parentheses.

#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC

We will globally enable syntax highlight

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config (add-hook 'after-init-hook #'global-flycheck-mode))

#+END_SRC

** Company mode

Company mode is used for autocompletion

I set the delay to 0 to prevent any waiting for the autocompletion popup to show

Usually it is not needed at the start (remember I use emacs daemon).

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :defer t
  :idle (global-company-mode)
  :config (progn
                (setq company-idle-delay .3)
                (setq company-echo-delay 0)
                (setq company-tooltip-limit 15)
                (setq company-minimum-prefix-length 1)))
#+END_SRC

** Clojure

#+BEGIN_SRC emacs-lisp
;; (add-hook 'cider-mode-hook #'eldoc-mode)

;; In case of errors with nREPL you can enable this
;; (setq nrepl-log-messages t)

;; Hide cider special buffers
(setq nrepl-hide-special-buffers t)

;; Print a maximum of 100 items per collection
(setq cider-repl-print-length 100)

(setq cider-repl-result-prefix ";; => ")
(setq cider-interactive-eval-result-prefix ";; => ")
#+END_SRC

** Haskell

#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
(add-hook 'haskell-mode-hook 'flycheck-mode)
#+END_SRC

** HTML, templates & CSS

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode (("\\.html?\\'" . web-mode)
         ("\\.html\\.erb\\'" . web-mode))
  :config
    (progn
      (setq web-mode-markup-indent-offset 2)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-enable-auto-pairing t)))
#+END_SRC

Also for SASS

#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :ensure t
  :mode (("\\.scss\\'" . scss-mode))
  :config (setq scss-compile-at-save nil))
#+END_SRC

Some projects I do use HAML

#+BEGIN_SRC emacs-lisp
(use-package haml-mode
  :ensure t)
#+END_SRC


** Markdown

#+BEGIN_SRC emacs-lisp
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
#+END_SRC

** Ruby

We will use RVM's provided Ruby

#+BEGIN_SRC emacs-lisp
(use-package rvm
  :ensure t
  :defer t
  :config (rvm-use-default))

#+END_SRC

Adding file types with no rb extension: rake files, irbrc...

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist
	     '("\\.\\(?:gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))

(add-to-list 'auto-mode-alist
               '("\\(Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))


;; Adding syntax checking
(add-hook 'ruby-mode-hook 'flymake-ruby-load)
(add-hook 'ruby-mode-hook 'flymake-cursor-mode)
(add-hook 'ruby-mode-hook 'yafolding-mode)

(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))

;; Projectile rails mode
(add-hook 'projectile-mode-hook 'projectile-rails-on)
#+END_SRC

Use Rubocop for Ruby code linting

#+BEGIN_SRC emacs-lisp
(use-package rubocop
  :ensure t
  :init (add-hook 'ruby-mode-hook #'rubocop-mode))
#+END_SRC

Project navigation with Robe

#+BEGIN_SRC emacs-lisp
(use-package robe
  :ensure t
  :init (progn
           (add-hook 'ruby-mode-hook 'robe-mode)
           (eval-after-load 'company
              '(push 'company-robe company-backends))
           (defadvice inf-ruby-console-auto (before activate-rvm-for-robe activate)
              (rvm-activate-corresponding-ruby))))
#+END_SRC


** Elixir

#+BEGIN_SRC emacs-lisp

(use-package alchemist
  :ensure t
  :config (setq alchemist-hooks-test-on-save t)
  :bind (("C-c m" . alchemist-mix)))
#+END_SRC

** Javascript

Linting and syntax checking.

Before having it available you need to run

npm install -g eslint babel-eslint eslint-plugin-react


#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :init (setq js-indent-level 4)
  :config (add-hook 'js-mode-hook 'js2-minor-mode))
#+END_SRC

React specific settings

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.json$" . js-mode))
(add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))
#+END_SRC

** Go

Go mode. This will also autoformat after saving following go standards

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :bind ("C-c C-r" . go-remove-unused-imports)
  :config (add-hook 'before-save-hook 'gofmt-before-save))
#+END_SRC


Autocomplete for Go. We will be using company mode too.

#+BEGIN_SRC emacs-lisp
(use-package company-go
  :ensure t
  :config (add-hook 'go-mode-hook (lambda ()
                                    (set (make-local-variable 'company-backends) '(company-go))
                                      (company-mode))))
#+END_SRC

** Elm

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t
  :init (progn
           (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
           (with-eval-after-load 'company
              (add-to-list 'company-backends 'company-elm))))

#+END_SRC

* Puppet

Puppet will use its own mode since Ruby mode can cause some weirdness there.

#+BEGIN_SRC emacs-lisp
(use-package puppet-mode
  :ensure t)
#+END_SRC

* Git

We will use Magit for git. Also opening timemachine is a nice binding to have.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("<f6>" . magit-status)))
#+END_SRC

Time machine is a nice package to browse the story of a file

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :ensure t
  :bind (("C-<f6>" . git-timemachine)))

#+END_SRC

Also for some projects it is nice to be able to browse the file on Github.

#+BEGIN_SRC emacs-lisp
(use-package github-browse-file
  :ensure t
  :bind (("C-c g f" . github-browse-file)))
#+END_SRC

And let's put a nice gutter

#+BEGIN_SRC emacs-lisp
;(use-package git-gutter
;  :ensure t
;  :init (progn
;           (global-git-gutter-mode t)
;           (git-gutter:linum-setup)
;            (custom-set-variables
;              '(git-gutter:update-interval 2))))
#+END_SRC


* Docker

Emacs is great for managing docker images. Also I will use the syntax help for Dockerfiles

#+BEGIN_SRC emacs-lisp
(use-package docker
  :ensure t)

(use-package dockerfile-mode
  :ensure t
  :config (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

#+END_SRC


* Vendored scripts

These are stand alone scripts I don't want in this config file.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/vendor/restclient")
(require 'restclient)
#+END_SRC

* Help and documentation

** Guide key

When I start typing a combo a help with the possible continuations appear if I wait for a while.

#+BEGIN_SRC emacs-lisp
(setq guide-key/guide-key-sequence t)
(guide-key-mode 1)
#+END_SRC

** Dash

Integration with Dash

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/vendor/dash-at-point")
(autoload 'dash-at-point "dash-at-point"
  "Search the word at point with Dash." t nil)
(global-set-key "\C-cd" 'dash-at-point)
(global-set-key "\C-ce" 'dash-at-point-with-docset)
#+END_SRC

* File navigation
** Neo tree

#+BEGIN_SRC emacs-lisp
(defun neotree-to-root ()
  "Moves neotree to root of project"
  (interactive)

  (let ((git-folder (car (projectile-get-project-directories))))
                              (neotree-dir git-folder)))

(use-package neotree
  :ensure t
  :bind ("<C-tab>" . neotree-toggle))
#+END_SRC

** Dired

Making dired to open the file in the current buffer instead of opening a new one

#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC

* Keyfreq

This is just for measuring the frequency for the commands run

#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :ensure t
  :init (progn
          (keyfreq-mode 1)
          (keyfreq-autosave-mode 1)
          (setq keyfreq-excluded-commands
            '(self-insert-command
              abort-recursive-edit
              previous-line
              next-line))))
#+END_SRC

* Applications
** RSS reader

I use elfeed to read RSS. It can be configured via and org mode file. Extra awesomeness!

#+BEGIN_SRC emacs-lisp

(use-package elfeed
  :ensure t
  :init (setf url-queue-timeout 30))

(use-package elfeed-org
  :load-path "vendor/elfeed-org"
  :init (progn
          (elfeed-org)
          (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed/elfeed.org"))))

#+END_SRC


* Some general purpose functions

These are some general functions that are useful and have no better place to be in

** Copy file to clipboard

Copies the file to the clipboard.

#+BEGIN_SRC emacs-lisp
(defun current_buffer_file_name ()
  (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name)))

(defun copy-path-to-clipboard ()
  "Copy the current buffer full file path to the clipboard."
  (interactive)
  (let ((filename (current_buffer_file_name)))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

(defun copy-filename-to-clipboard ()
  "Copy the current buffer file name relative to projectile root to the clipboard."
  (interactive)
  (let* ((base_path (car (projectile-get-project-directories)))
         (filename (replace-regexp-in-string base_path "" (current_buffer_file_name))))
     (when filename
       (kill-new filename)
       (message "Copied buffer file name '%s' to the clipboard." filename))))

#+END_SRC

** Chrome reload

This function just reloads chrome. This is useful to avoid too much alt-tab

#+BEGIN_SRC emacs-lisp
(defun chrome-reload ()
  "Reloads current chrome window"
  (interactive)
  (shell-command "chrome-cli reload"))

(define-prefix-command 'manage-browser-map)
(global-set-key (kbd "C-b") 'manage-browser-map)

(defun chrome-reload ()
  "Reloads current chrome window"
  (interactive)
  (shell-command "chrome-cli reload"))

(define-key manage-browser-map "r" 'chrome-reload)
#+END_SRC

* Custom scripts

These are scripts that are worthy of their own source file and I'm not including them here.

#+BEGIN_SRC emacs-lisp
(use-package copy-rtf
  :load-path "src/copy-rtf")

(use-package p161-mode
  :load-path "src/p161-mode"
  :bind ("C-c t" . send-test-to-tmux))

(load-file "~/.emacs.d/src/emacs-presentation-mode/emacs-presentation-mode.el")
#+END_SRC
